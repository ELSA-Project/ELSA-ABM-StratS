
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Used for interface with Distance library.
"""

import sys
sys.path.insert(1, '..')
import pickle
from string import split
from shapely.geometry import LineString, MultiPolygon, Point
from shapely.ops import cascaded_union

from libs.tools_airports import get_set, __version__ as distance_version, build_path, build_network_based_on_shapes, TrajConverter
from libs.general_tools import date_generation, draw_network_and_patches
from utilities import extract_data_from_files, Paras, draw_network_map_bis

# def name(paras_nav, data_version):
# 	version = data_version if data_version!=None else distance_version
# 	path = build_path(paras_nav, version, full=False)
# 	_name = 'Real'
# 	for piece in split(split(path, 'Distance/')[1], '/'):
# 		_name += '_' + piece
# 	return _name

def paras_strategic(zone='LF', airac=334, starting_date=[2010,5,6], n_days=1, cut_alt=240.,\
	mode='sectors', data_version=None, password_db='4ksut79f', type_zone='EXT', redo_FxS=False):

	"""
	Custom paras building for the distance library.
	"""

	paras = {'zone':zone, 'airac': airac, 'starting_date':starting_date, 'n_days':n_days,\
	 'cut_alt':cut_alt, 'mode':mode}
	paras['type_zone'] = type_zone		# 'INT' selects only flights which departs and arrives in the zone, 'SEMI' selects those 
						# which departs or arrives (inclusive) and 'EXT' selects all flights. 
	paras['filtre']='Strong'		# See deliverable 1.3 for exact definition. 'Strong' selects the commercial
						# flights in a first approximation.
	paras['timeStart']=[0,0,0]			# hour, minutes, seconds.
	paras['timeEnd']=[23,59,59]
	paras['type_of_deviation']='absolute' 	# 'absolute' computes the value generated by the point. "derivative" compute the derivated with respect to the previous point.
	paras['nodes'] = 'm1'			# types of nodes for building the network (m1 or m3)
	paras['use_database']=False	# Use directly the database without checking if there is a already the data on the disk.
	paras['make_basic']=False		# Compute basic metrics (degree, strength) of the network.
	paras['make_dev']=False		# Compute advanced metrics (number of flights deviated and so on...)
	paras['make_save']=True 		# Save results.
	paras['make_plots']=False	# Make (many) plots. Can be also done with do_plots script afterwards.
	paras['verb']=True			# set to true for more information during the execution.
	paras['use_base_net']=False	# Set to True to compute also the network with all flights and use its metrics to compare 
						# with the metrics of traffic from the trajectories selected by these parameters.
	paras['redo_FxS']= redo_FxS		# Important only for nav_sec or sec. Putting "True" is safer
	paras['use_DB_for_net']=False # ?
	paras['data_version'] = data_version #'5.7' #Version of network and traffic data that the code tries to load (leave None for current version)
	paras['ext_area']=False		# expand slightly the sectors' boundaries in order to include navpoints
						# which are exactly on the boundary.
	paras['d']=2 				# set to 3 for navpoints if you want a 3d representation of the trajectories.
	paras['direct']=True 		# Set to True for directed network.
	paras['micromode']=False 	# This is used for computing metrics hour by hour.
	paras['step']=1				# same thing, step in hours.
	paras['force']=True			# Set to True if you want to recompute and rewrite results which are already on the
						# disk.
	paras['compress']=True 		# Compress the results for each day.
	
	paras['collapsed']=False		# This is used to collapsed results hour per hour when using micromode. More or less.
	paras['gather_sectors']=False # Not sure what this is (but it's linked to collapsed).
	paras['do_local']=True 		# Used to compute local metrics of frac, etc.
	paras['both']=False			# Compute the network with m1 AND m3 points.
	#password_db = 'c1p0sql'	# Passowrd for database
	#address_db = '147.163.52.108' 	# Ip adress of DB
	paras['password_db'] = password_db	# Password for database
	paras['address_db'] = 'localhost' 	# Ip adress of DB

	paras['main_rep'] = '/home/earendil/Documents/ELSA/Distance/'

	cut_alt = float(cut_alt)

	timeStart=paras['starting_date'][:]
	for l in paras['timeStart']:
		timeStart.append(int(l))
	paras['timeStart']=timeStart
	timeEnd=date_generation(paras['starting_date'],paras['n_days'])[-1]   # A CHANGER
	for l in paras['timeEnd']:
		timeEnd.append(int(l))
	paras['timeEnd']=timeEnd

	return paras

def build_paras_G(zone='LF', data_version=None, layer=350., checks=True, show=True, name='LF', max_sectors=None, **kwargs_distance):
	#from paras_G import paras_G # TODO Change this, this is really bad.

	paras_G = Paras({})

	paras_G['name'] = name

	# Get flights
	paras = paras_strategic(zone=zone, mode='sectors', data_version=data_version, **kwargs_distance)
	seth = get_set(paras, force=False)
	G_dummy, flights = seth.G, seth.flights

	#paras_G['G_dummy'] = G_dummy # TO REMOVE AFTER DEBUG

	# Get sector network
	paras_G['file_net_sec'] = None
	G, polygons = build_network_based_on_shapes(paras['password_db'], paras['airac'], zone, layer)
	polygons = fix_overlapping_polygons(polygons)
	G, polygons = recompute_centroids(G, polygons)
	paras_G['net_sec'] = G
	print "Number of nodes in sec network:", len(G.nodes())
	paras_G['type_of_net'] = 'R'

	# Get polygons
	paras_G['file_polygons'] = None
	paras_G['polygons'] = polygons
	print "Number of polygons:", len(paras_G['polygons'])

	# Select the flights used to build the capacities and weights
	print 'Converting trajectories'
	trajconverter = TrajConverter()
	trajconverter.set_G(G_dummy)

	new_trajs = convert_distance_trajectories_to_abm_format(flights.values()[:], fmt='(n, z, t)')

	trajconverter = TrajConverter()
	trajconverter.set_G(G_dummy)

	converted_trajs = trajconverter.convert(new_trajs, fmt_in='(n, z, t)', fmt_out='(x, y, z, t)', input_minutes=True)

	final_trajs = detect_sectors(polygons, converted_trajs)

	if max_sectors!=None:
		G, polygons, final_trajs = reduce_sectors(max_sectors, G, polygons, final_trajs)

	paras_G['file_flights_selected'] = None
	paras_G['flights_selected'] = final_trajs
	paras_G['format_flights'] = '(n, z, t)'

	# Generate capacities based on traffic
	paras_G['file_capacities'] = None
	paras_G['generate_capacities_from_traffic'] = True
	paras_G['min_capacity'] = 1

	# Take airports from traffic
	paras_G['file_airports_sec'] = None
	paras_G['generate_airports_from_traffic'] = True
	
	# Generate weights (times of travel) based on traffic
	paras_G['file_weights'] = None
	paras_G['generate_weights_from_traffic'] = True
	paras_G['generate_only_average_weight_from_traffic'] = True

	# Take connections from data
	paras_G['generate_connections_from_traffic'] = True
	paras_G['min_dis'] = 2

	# Other parameters
	paras_G['Nfp'] = 10	

	# if checks:
	# 	try:
	# 		for f in paras_G['flights_selected']:
	# 			for n, alt in f[route]:
	# 				assert n in G.nodes()
	# 	except AssertionError:
	# 		raise Exception("Some nodes in trajectories are missing in the network's nodes.")

	# 	try:
	# 		for a in airports:
	# 			assert a in G.nodes()
	# 	except AssertionError:
	# 		raise Exception("Some airports are missing in the network's nodes.")

	paras_G = extract_data_from_files(paras_G)
	paras_G.analyse_dependance()

	return paras_G

def trajectories_from_data(zone='LF', fmt='(n, z, t)', data_version=None, save_file=None, **kwargs_distance):
	"""
	Produce some trajectories with signature ['(n, z, t)', '(n, z), t', '(n), t', or '(n, t)'
	"""
	try:
		assert fmt in ['(n, z, t)', '(n, z), t', '(n), t', '(n, t)']#, ('n', 'z', 'timeint'), (('n', 'z'), 'timeint')]
	except:
		Exception("Format", fmt, "is not implemented.")

	# Get navpoints network
	paras_nav = paras_strategic(zone=zone, mode='sectors', data_version=data_version, **kwargs_distance)
	seth = get_set(paras_nav, force=False)
	G, flights_nav = seth.G, seth.flights

	trajectories = []
	for f in seth.flights.values():
		points, altitudes = zip(*f['route_m1'])
		if fmt == '(n, z, t)':
			trajectories.append([(points[i], altitudes[i], f['route_m1t'][i][1]) for i in range(len(points))])
		elif fmt == '(n, t)':
			trajectories.append([(points[i], f['route_m1t'][i][1]) for i in range(len(points))])	
		elif fmt == '(n, z), t':
			trajectories.append(([(points[i], altitudes[i]) for i in range(len(points))], f['route_m1t'][0][1]))
		elif fmt == '(n), t':
			trajectories.append(([points[i] for i in range(len(points))], f['route_m1t'][0][1]))

	return trajectories, G

def convert_distance_trajectories_to_abm_format(flights, m1=True, m3=False, fmt='(n, z, t)'):
	if m1:
		trajectories_m1 = []
		for f in flights:
			points, altitudes = zip(*f['route_m1'])
			if fmt == '(n, z, t)':
				trajectories_m1.append([(points[i], altitudes[i], f['route_m1t'][i][1]) for i in range(len(points))])
			elif fmt == '(n, t)':
				trajectories_m1.append([(points[i], f['route_m1t'][i][1]) for i in range(len(points))])	
			elif fmt == '(n, z), t':
				trajectories_m1.append(([(points[i], altitudes[i]) for i in range(len(points))], f['route_m1t'][0][1]))
			elif fmt == '(n), t':
				trajectories_m1.append(([points[i] for i in range(len(points))], f['route_m1t'][0][1]))

	if m3:
		trajectories_m3 = []
		for f in flights:
			points, altitudes = zip(*f['route_m3'])
			if fmt == '(n, z, t)':
				trajectories_m3.append([(points[i], altitudes[i], f['route_m3t'][i][1]) for i in range(len(points))])
			elif fmt == '(n, t)':
				trajectories_m3.append([(points[i], f['route_m3t'][i][1]) for i in range(len(points))])	
			elif fmt == '(n, z), t':
				trajectories_m3.append(([(points[i], altitudes[i]) for i in range(len(points))], f['route_m3t'][0][1]))
			elif fmt == '(n), t':
				trajectories_m3.append(([points[i] for i in range(len(points))], f['route_m3t'][0][1]))

	if m1 and m3:
		return trajectories_m1, trajectories_m3
	elif m1 and not m3:
		return trajectories_m1
	elif not m1 and m3:
		return trajectories_m3
	else:
		return None

def produce_M1_trajs_from_data(zone='LF', data_version=None, put_fake_sectors=False, save_file=None, **kwargs_distance):
	"""
	Produce some trajectories with signature (x, y, z, t) from data.

	"""
	# Get navpoint network
	paras = paras_strategic(zone=zone, mode='sectors', data_version=data_version, **kwargs_distance)
	seth = get_set(paras, force=False)
	G, flights = seth.G, seth.flights # G is a network from Distance library, not from the ABM.

	trajectories = []
	for f in seth.flights.values():
		#print f['route_m1']
		#print zip(*f['route_m1'])
		#raise Exception()
		points, altitudes = zip(*f['route_m1'])
		if not put_fake_sectors:
			traj = [(G.node[points[i]]['coord'][0]/60., G.node[points[i]]['coord'][1]/60., altitudes[i],\
				 f['route_m1t'][i][1]) for i in range(len(points))]
		else:
			traj = [(G.node[points[i]]['coord'][0]/60., G.node[points[i]]['coord'][1]/60., altitudes[i], \
				 f['route_m1t'][i][1], 0) for i in range(len(points))]
		# else:
		# 	raise Exception("I can't put sectors, not implemented yet.")
		# 	# The problem with the following is that G is not a network from the ABM but from distance.
		# 	traj = [(G.node[points[i]]['coord'][0]/60., G.node[points[i]]['coord'][1]/60., 
		# 			altitudes[i], f['route_m1t'][i][1], G.node[points[i]]['sec']) for i in range(len(points))]
		
		trajectories.append(traj)

	if save_file!=None:
		write_trajectories_for_tact(trajectories, fil=save_file) 

	return trajectories

def detect_sectors(polygons, trajectories):
	"""
	Recompute the trajectories based on the polygons given. 

	Format of the trajectories should be '(x, y, z, t)'

	The output format is '(n, z, t)', but the nodes are the projected sectors
	(instead of the sectors from the original sectors).

	"""

	new_trajectories = []
	for traj in trajectories:
		prev_sec = None
		new_traj = []
		for j in range(len(traj)-1):
			x1, y1, z1, t1 = traj[j]
			x2, y2, z2, t2 = traj[j+1]
			pt1 = Point((x1, y1))
			pt2 = Point((x2, y2))
			sec1, sec2 = [], []
			for name, shape in polygons.items():
				if shape.contains(pt1):
					sec1.append(name)
				if shape.contains(pt2):
					sec2.append(name)

			if len(sec1)==0:
				pass #?
			elif len(sec1)==1:
				if not (prev_sec==None or sec1[0]==prev_sec):
					print 'First point is not in the previous sector, but I skip'
			else:
				raise Exception('This point:', pt1, 'is within several polygons:', sec1)

			if len(sec2)==0:
				pass #?
			elif len(sec2)==1:
				if sec2[0]!=prev_sec:
					new_traj.append((sec2[0], z2, t2))
					prev_sec = sec2[0]
			else:
				raise Exception('This point:', pt2, 'is within several polygons:', sec2)

		#new_traj = [new_traj, traj[0][3]]
		new_trajectories.append(new_traj)

	return new_trajectories

def fix_overlapping_polygons(polygons):
	"""
	If two overlapping polygons are found, drop the smallest.
	"""
	modified = 1 
	n_turn = 0
	while modified>0:
		print 'Turn', n_turn
		modified = 0 
		names = polygons.keys()#[:100]
		for i in range(len(names)):
			pol1 = polygons[names[i]]
			for j in range(i+1, len(names)):
				assert i!=j
				pol2 = polygons[names[j]]
				if pol1.intersection(pol2).area>0.:
					print 'polygon:', names[i], 'and polygon:', names[j], 'cross each other'
					print 'Areas:', pol1.area, pol2.area
					print 'Intersection area:', pol1.intersection(pol2).area
					# Replace the biggest by the differencc between the biggest and the smallest
					modified += 1
					if pol1.area<pol2.area:
						polygons[names[j]] = pol2.difference(pol1)
						print 'I modified:', names[j]
					else:
						polygons[names[i]] = pol1.difference(pol2)
						print 'I modified:', names[i]
		

		print 'I modified', modified, 'polygons'
		print

		n_turn += 1

	# Check for Multipolygons and reduce them to their biggest part
	for name, pol in polygons.items():
		if type(pol)==MultiPolygon:
			print 'Polygon', name, 'is a Multipolygon'
			list_per_area = sorted(list(pol), key=lambda x:x.area)
			print 'List of areas:', [x.area for x in list_per_area]
			# Select the biggest piece
			polygons[name] = list_per_area[-1]

	return polygons

def recompute_centroids(G, polygons):
	for n in G.nodes():
		pol = polygons[n]
		centre = pol.centroid.coords[0]
		G.node[n]['coord'] = list(centre)

	return G, polygons

def reduce_sectors(N, G, polygons, trajectories, fmt_in='(n, z, t)'):
	# Overall center
	centre = cascaded_union(polygons.values()).centroid
	to_remove = sorted(G.nodes(), key=lambda x:polygons[x].centroid.distance(centre), reverse=True)
	distances = sorted([polygons[x].distance(centre) for x in G.nodes()])
	n_to_remove = len(G)-N
	to_remove = to_remove[:n_to_remove]

	# Reduce nodes and polygons
	for n in to_remove:
		del polygons[n]
		G.remove_node(n)

	print 'Removed', n_to_remove, 'sectors'

	n_traj = len(trajectories)
	for traj in trajectories[:]:
		for n, z, t in traj:
			if not n in G.nodes() and traj in trajectories:
				trajectories.remove(traj)
				continue

	print 'Removed', n_traj-len(trajectories), 'trajectories'

	return G, polygons, trajectories



if __name__=='__main__':
	#build_net_distance(zone='LF', show=True)
	paras_G = build_paras_G(zone='ECAC',#['LF', 'LI'],
							data_version=None, 
							layer=350., 
							cut_alt=0.,
							checks=True, 
							show=True, 
							name='ECAC', 
							airac=334,
							#starting_date=[2011,6,3],
							starting_date=[2010,5,6],
							password_db='4ksut79f',
							type_zone='EXT',
							redo_FxS=True,
							max_sectors=60)

	

	# # #print paras_G['flights_selected'][0]
	# new_trajs = convert_distance_trajectories_to_abm_format(paras_G['flights_selected'], fmt='(n, z), t')

	# # #print paras_G['polygons'].keys()

	# trajconverter = TrajConverter()
	# trajconverter.set_G(paras_G['G_dummy'] )

	# converted_trajs = trajconverter.convert(new_trajs, fmt_in='(n, z), t', fmt_out='(x, y, z, t)', input_minutes=True)

	# print
	# print paras_G['polygons'].values()[0]
	# print
	# print converted_trajs[0]
	# print

	# final_trajs = detect_sectors(paras_G['polygons'], converted_trajs[:10])

	# for traj in final_trajs[:10]:
	# 	print traj
	# 	print

	if 1:
		from prepare_network import extract_weights_from_traffic, hard_infrastructure
		from simAirSpaceO import Net 
		G = Net()
		G.type = 'sec' #for sectors
		G.type_of_net = paras_G['type_of_net']
		hard_infrastructure(G, paras_G)
		weights = extract_weights_from_traffic(G, paras_G['flights_selected'], fmt_in='(n, z, t)')
		G.fix_weights(weights, typ='traffic')
		G.typ_weights = 'data'
		draw_network_and_patches(G, None, paras_G['polygons'], 
						draw_navpoints_edges=False,
						draw_sectors_edges=True, 
						scale_edges=True,
						rep='.', 
						save=False, 
						name='network',
						show=True, 
						flip_axes=True, 
						trajectories=[], 
						trajectories_type='navpoints', 
						dpi = 100, 
						figsize = None)



	# trajectories = produce_M1_trajs_from_data(zone='LF', put_sectors=False)
	# for traj in trajectories[:5]:
	# 	print traj
	# 	print

